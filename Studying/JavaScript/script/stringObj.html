<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <p id="dy"></p>
    <script>
        // String 객체... 스크립트에서 사용되는 모든 문자열은 자동을 객체로 생성이되어집니다.
        // 따라서 속성과 메서드가 존재 하는데, 이장에서는 이것들의 개념과 사용방법을 알아볼게요

        let msg = "Hello Worldoooooooooooooooooooooooooooooooooooooooooooooo";


        let leng = msg.length; // 문자열의 길이를 리턴하는 속성..
        console.log(leng);

        // 배열을 사용해봅니다.
        let header = "Template Strings"
        let tags = ["template strings", "script", 'es6문법'];

        let html = `<h2>${header}</h2><ul>`;
        for (const x of tags) {
            html += `<li>${x}</li>`;
        }
        html += `</ul>`;
        document.getElementById('dy').innerHTML = html;

        msg = 'abcdefg'
        for (let i = 0; i < msg.length; i++) {
            let code = msg.charCodeAt(i);
            console.log(code);
        }

        msg = 'abc';
        msg = msg.concat('def');
        msg //결과가 abcdef로 나옴  concat : concat(str1) or concat(str1, str2) or concat(str1, str2, /* …, */ strN)

        let slice = msg.slice(2);
        slice //결과가 cdef로 나옴

        slice = msg.slice(3, 5);
        // 결과는 de로 나옴 slice : slice(indexStart, indexEnd)

        let str = "apple, banana, kiwi";
        str.substr(7, 6);
        // 바나나만 분리됨 substr : substr(start, length)

        str.substring(7, 13);
        // 이것도 바나나만 분리됨 substring : substring(indexStart, indexEnd)

        str.substring(str.length - 4);
        // 키위 분리 

        'abc'.toUpperCase() // abc를 대문자로 만듦
        'abc'.toUpperCase().toLowerCase() // abc를 대문자로 만들었던것을 다시 소문자로 만듦 리턴값을 알면 계속 이어서 작성할 수 있음

        // let kor = parseInt(prompt('국어 입력'));
        let kor = '  10  ';
        alert(kor.trim().length); // trim() : str 시작과 끝의 공백이 제거된 새로운 문자열을 반환함

        msg = "abcdefcdef".replace('e', 'k'); // e 첫번째 문자를 k로 바꿈, replace : 대치
        msg = "abcdefcdef".replace('/e/g', 'k'); //모든 e 문자를 k로 바꿈 

        txt = "go somewhere and do somthing";
        txt.indexOf("do"); //do가 위치한 index 번호를 반환함 indexOf() : 찾으려는 문자의 첫번째 인덱스를 반환하고 찾을 수 없으면 -1을 반환함

        txt = "go somewhere and do somthing or just do it now";
        txt.indexOf("do", txt.indexOf("do") + 1); //첫번째 do 다음에 나오는 do의 index 번호를 반환함

        // search는 정규 표현식을 사용 가능, but indexOf는 정규 표현식 사용 불가능
        let ss = "do something or just do it";
        let sear = ss.search(/just/);
        // 정규 표현식과 주어진 문자열이 처음 일치하는 인덱스를 반환함

        let mat = str.match(/do/g); // (2) ['do', 'do'] 를 반환함
        // 문자열이 정규식과 일치하면, 일치하는 전체 문자열을 첫 번째 요소로 포함하는 Array를 반환한 다음 괄호 안에 캡처된 결과가 옵니다

        mat = str.matchAll(/cats/gi);

        // to String : 모든 타입의 객체를 문자열로 재정의함
        num = new Number(1);
        num.toString();


        // 배열 Array : 배열은 객체이다. 이객체를 생성하고 변수에 할당(reference)
        // 해서 하나 이상의 값을 하나의 객체 변수를 이용해서 관리하는데 주 목적이 있다.
        // 문법 : [] 이 표식자가 배열이다

        const raes = ['bmw', 'benz', 'hyundai'];

        // 괄호가 없으면 속성, 괄호가 있으면 메서드

        // 배열의 대표적인 순환반복문인 forEach를 알려줄게요
        // forEach(callBackFunction) 는, 내부적으로 배열의 모든 index를 반복해서 접근한 후에 그 값을 리턴해줍니다.
        // 이때 그 값을 어떻게 처리할 것인지를 구현한 콜백 함수를 파라미터로 받도록 정의 되어있어요.
        // 해서 그 콜백 함수를 인자값으로 전해줍니다.
        const fru = ['banana', 'orange', 'apple', 'mango'];

        let text = "";
        function mtf(value) {
            text += value;
        }
        fru.forEach(mtf)

        text // 'bananaorangeapplemango' 결과가 이렇게 나옴


        fru.forEach((value) => console.log(value)); //람다 사용


        // forIn : 배열의 모든 요소를 접근 하는 루프문
        // syntax : for(값 변수 in 배열객체){구문형태}


        fru.join("*") //,를 *로 바꿔줌 join(separator) : 배열의 모든 요소들을 연결한 하나의 문자열을 반환합니다. 만약 arr.length 가 0이라면, 빈 문자열을 반환




        function countBigger(numbers) {
            // 여기에 로직 구현
            let count = 0;
            numbers.forEach(value => {
                if (value < 10) {
                    count++;
                }
            });

            return count;
        }

        const count = countBigger([1, 2, 3, 4, 5, 10, 20, 4, 8, 100]);

        // console.log(count) 하게 되면 10 보다 작은 수들의 개수를 출력하세요.
        console.log(count);





        //     function countBigger(numbers) {
        //         let count = 0;
        //         forEach 이용해보기
        //         numbers.forEach(value => {
        //             if(value < 10){
        //                 count++;
        //             }
        //         });
        //         return count;
        //     }
        //     const count = countBigger([1, 2, 3, 4, 5, 10, 20, 4, 8, 100]);

        //     console.log(count) 하게 되면 10 보다 작은 수들의 개수를 출력하세요.
        //     console.log(count);


        let arr = [1, 2, 3, 4, 5];
        const squar = n => n * n; // n 파라미터 값을 n * n해서 리턴하라는 람다함수





        const todos = [
            {
                id: 1,
                text: '스크립트 입문',
                done: true
            },
            {
                id: 2,
                text: '스크립트 배열',
                done: false
            },
            {
                id: 3,
                text: '객체',
                done: false
            }
        ]

        const ids = [];
        todos.forEach(todo => {
            ids.push(todo.id)
        })
        console.log(ids)

        // todos를 순회하면서 todo라는 이름의 객체의 id를 ids라는 빈 배열에 넣는다.




        // todos를 find를 이용해서 작업이 완료된 첫번째 객체 id와 과목명 출력
        const obj = todos.find(todo => {
            return todo.done == true;
        });

        console.log(obj.id, obj.text)

        // filter를 이용해서 미완된 과목의 배역을 생성하세요(list 배열명으로 만드세요)
        const list = [];
        todos.filter(todo => {
            return todo.done != true;
        })
        list.forEach(obj => console.log(obj.text));





        const ironman = {
            name: '스타크',
            actor: '로다주',
            alias: '아이언맨'
        }

        function print(theHero) {
            const text = `${theHero.alias}(${theHero.name}) 역할을 한 배우는 ${theHero.actor} 임`
            console.log(text);
        }

        print(ironman) //아이언맨(스타크) 역할을 한 배우는 로다주 임 이라는 결과 출력




        // 객체 비구조화 할당 : 객체를 구조 분해 한다는 의미로, 객체의 key를 먼저 선언하고,
        //  객체를 할당을 시키면 자동으로 키의 값으로 객체를 분해해서 값을 할당함.

        function print(theHero) {
            // 객체 구조 분해해서 값을 바인딩함.
            const { name, actor, alias } = theHero;
            const text = `${alias}(${name}) 역할을 한 배우는 ${actor} 임`
            console.log(text);
        }

        print(ironman) // 아이언맨(스타크) 역할을 한 배우는 로다주 임



        // getter, setter 예시
        const numbers = {
            a: 1,
            b: 2,
            sum: 3,

            calculate() {
                console.log('calc');
                this.sum = this.a + this.b;
            },
            get aa() {
                return this.a;
            },
            get bb() {
                return this.b;
            },
            // setter 정의
            set aa(value) {
                console.log('a 가 바뀜');
                this.a = value;
                this.calculate();
            },
            set bb(value) {
                console.log('b 가 바뀜');
                this.b = value;
                this.calculate();
            }
        }








        // 생성자(Constructor) : 객체의 원형이 되는 일종의 클래스
        // 이 생성자에 객체가 가져야할 속성과 메서드를 정의해서 필요할 때 값을 초기화 하거나
        // 빈객체를 생성해서 생성된 객체가 일을 할 수 있도록 하는 일종의 설계도라고 생각하세요
        // 생성자 함수 정의... 첫자는 대문자로 하는게 일반적

        // 우리반 학생들 객체를 생성하기 위해서 생성자 함수를 정의함
        // 공통적으로 가져야 할 속성과 행위(메서드)를 정의하는 것으로함

        function BCampStu(name, age) {
            this.name = name;
            this.age = age;
        }
        // 위처럼 생성자를 정의한 경우, 객체를 추출하기 위해서는 new 하는 키워드를 이용, 
        // 생성자를 호출함
        const hyun = new BCampStu('현민', 25);
        // 속성을 추가해 보자
        hyun.city = '경기도'; // 동적으로 추가함 별로 선호하진 않음 
        // Prototype 을 이용해서 동적으로 속성이나 메서드를 추가할땐,
        //  생성자.prototype.속성명 = value 
        BCampStu.prototype.nation = 'korea';
        hyun.nation;



        // changeName 이라는 메서드를 prototype을 이용해서 생성자에 추가하세요
        // 새로운 이름을 받아서 기종의 이름을 변경하도록 메서드는 정의하세요.
        function BCampStu(name, age) {
            this.name = name;
            this.age = age;
        };

        BCampStu.prototype.changeName = function (Newname) {
            this.name = Newname;
        };

        const person = new BCampStu('hyun', 25);
        person.changeName('Choi');

        // 자바스크립트의 내장 객체는 기본적으로 생성자함수를 모두 가지고 있습니다.
        const arr1 = new Array();


        //  key,key ...rest 문법 : 배열의 나머지 값을 새배열에 담아서 해당 배열을 리턴시키는 방법,
        //  많이 쓰임


        // 반올림에 관련 메서드.. toExponential();
        // 이 스크립트는 수치는 기본적으로 Number 객체로 할당되어 관리됩니다.
        // 때문에 속성과 메서드를 바로 사용할 수 있음

        let cookieDate = 'init:2025.01.01;exp=2025.01,08';

        const idx = cookieDate.indexOf('exp=') + 4;
        let str1 = cookieDate.slice(idx);

        let day = new Date(str1);

        // 날짜끼리 비교연산 가능
        if (now > day) {
            console.log("당신의 쿠키 유효기간이 만료되었습니다.");
        }


        // 정규화식의 flag : g(문자열 전체검색), 
        // i(대소문자 구분여부), m(문자열의 변경 라인 포함) 등...
        let text1 = "Visit School";
        // 검색할 패턴생성
        let pattern = /is/g;
        text.match(pattern); //결과 : ['is']

        text = 'aaaabb';
        pattern = /(aa)(bb)/d;
        text.match(pattern); // 결과 : ['aabb', 'aa', 'bb', index: 2, input: 'aaaabb', groups: undefined, indices: Array(3)]

        text.replace(/B/i); //결과 : 'aaaaundefinedb'
        text.replace(/B/i, 'c'); //결과 : 'aaaacb'

        text = 'Black, white, red, green, blue, yellow';
        // 위 문자열에서 red or green or blue를 찾아서 배열로 리턴시키려고 함
        let res = text.match(/red|green|blue/g); // 결과 : (3) ['red', 'green', 'blue']

        // [] 의미 : 괄호 내의 문자를 전역적으로 검색함. 필요에 따라서 -를 지정해서 범위를 지정할 수 있음
        text = 'Hello World';
        pattern = /[HW]/g;
        text.match(pattern); // 결과 : ['H', 'W']


        // 수량 한정자
        // {n, m } 표식자
        // n개 또는 m개
        // {n} : 뒤에 n개의 문자
        // {1,} : 1개 이상의 문자가 존재 하는지...
        text = 'The fear of the LOAD is the bigging of Knowledge';
        text.match(/t.{1,2}/gi); // 결과 : (3) ['The', 'the', 'the']

        // t로 시작하고 뒤에 문자 4개인 단어들을 찾아보세요.
        text.match(/t.{4}/gi); // 결과 : (3) ['The f', 'the L', 'the b']

        // of of가 나오도록 찾아보세요
        text.match(/of{1,}/g); // 결과 :(2) ['of', 'of']

        // t로 시작하는 두글자 '또는' o로 시작하는 두글자를 찾아보세요
        text.match(/t.|o./g); // 결과 : (5) ['of', 'th', 'th', 'of', 'ow']

        pattern = /\b[a-z]{3}/g;
        text.match(pattern); // 결과 : ['fea', 'the', 'the', 'big']

        // [^A-Za-z\s]+ : 공백, 알파벳을 제외한 1개 이상의 문자를 추출하라는 의미
    </script>
 
</body>

</html>